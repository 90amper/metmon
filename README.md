# 90amper MetMon Repository

Репозиторий для трека «Сервер сбора метрик и алертинга» из шаблона go-musthave-metrics-tpl

## Обновление шаблона

Чтобы иметь возможность получать обновления автотестов и других частей шаблона, выполните команду:

```
git remote add -m main template https://github.com/Yandex-Practicum/go-musthave-metrics-tpl.git
```

Для обновления кода автотестов выполните команду:

```
git fetch template && git checkout template/main .github
```

Затем добавьте полученные изменения в свой репозиторий.


## iter1
* Принимать и хранить произвольные метрики двух типов:
    - Тип gauge, float64 — новое значение должно замещать предыдущее.
    - Тип counter, int64 — новое значение должно добавляться к предыдущему, если какое-то значение уже было известно серверу.
* Принимать метрики по протоколу HTTP методом POST.
* Принимать данные в формате `http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>, Content-Type: text/plain`.
* При успешном приёме возвращать `http.StatusOK`.
* При попытке передать запрос без имени метрики возвращать `http.StatusNotFound`.
* При попытке передать запрос с некорректным типом метрики или значением возвращать `http.StatusBadRequest`.

## iter3
Доработайте сервер так, чтобы в ответ на запрос `GET http://<АДРЕС_СЕРВЕРА>/value/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>` он возвращал текущее значение метрики в текстовом виде со статусом `http.StatusOK`.

При попытке запроса неизвестной метрики сервер должен возвращать `http.StatusNotFound`.

По запросу `GET http://<АДРЕС_СЕРВЕРА>/` сервер должен отдавать HTML-страницу со списком имён и значений всех известных ему на текущий момент метрик.
Хендлеры должны взаимодействовать с экземпляром MemStorage при помощи соответствующих интерфейсных методов.

## iter4
Аргументы сервера:
- Флаг `-a=<ЗНАЧЕНИЕ>` отвечает за адрес эндпоинта HTTP-сервера (по умолчанию localhost:8080).

Аргументы агента:
- Флаг `-a=<ЗНАЧЕНИЕ>` отвечает за адрес эндпоинта HTTP-сервера (по умолчанию localhost:8080).
- Флаг `-r=<ЗНАЧЕНИЕ>` позволяет переопределять `reportInterval` — частоту отправки метрик на сервер (по умолчанию 10 секунд).
- Флаг `-p=<ЗНАЧЕНИЕ>` позволяет переопределять `pollInterval` — частоту опроса метрик из пакета `runtime` (по умолчанию 2 секунды).

При попытке передать приложению незвестные флаги оно должно завершаться с сообщением о соответствующей ошибке.
Значения интервалов времени должны задаваться в секундах.
Во всех случаях должны присутствовать значения по умолчанию.

## iter5
Доработайте агент, чтобы он мог изменять свои параметры запуска по умолчанию через переменные окружения:
- `ADDRESS отвечает` за адрес эндпоинта HTTP-сервера.
- `REPORT_INTERVAL` позволяет переопределять `reportInterval`.
- `POLL_INTERVAL` позволяет переопределять `pollInterval`.

Значения интервалов времени должны задаваться в секундах.

Доработайте сервер, чтобы он мог изменять свои параметры запуска по умолчанию через переменные окружения:
- `ADDRESS` отвечает за адрес эндпоинта HTTP-сервера.

Приоритет параметров должен быть таким:
- Если указана переменная окружения, то используется она.
- Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
- Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

## iter6
Реализуйте логирование сведений о запросах и ответах на сервере для всех эндпоинтов, которые у вас уже есть. 

Сведения о запросах должны содержать URI, метод запроса и время, затраченное на его выполнение.

Сведения об ответах должны содержать код статуса и размер содержимого ответа.

Эту функциональность нужно реализовать через middleware. Используйте один из сторонних пакетов для логирования:
- `github.com/rs/zerolog`
- `go.uber.org/zap`
- `github.com/sirupsen/logrus`

Все сообщения логера должны быть на уровне Info.

## iter7
Дополните API сервера, чтобы позволить ему принимать метрики в формате JSON.

При реализации задействуйте одну из распространённых библиотек:
- `encoding/json`
- `github.com/mailru/easyjson`
- `github.com/pquerna/ffjson`

Обмен с сервером организуйте с использованием следующей структуры:
``` go
  type Metrics struct {
     ID    string   `json:"id"`              // имя метрики
     MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
     Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
     Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
  } 
```
Для передачи метрик на сервер используйте `Content-Type: application/json`. В теле запроса должен быть описанный выше JSON. Передавать метрики нужно через `POST update/`. В теле ответа отправляйте JSON той же структуры с актуальным (изменённым) значением Value. 

Для получения метрик с сервера также используйте `Content-Type: application/json`. В теле запроса должен быть описанный выше JSON с заполненными полями `ID` и `MType`. Запрашивать нужно через `POST value/`. В теле ответа должен приходить такой же JSON, но с уже заполненными значениями метрик. 

Переведите агент на новый API.

Update API
```shell
oapi-codegen -generate types -o internal/models/openapi_types.gen.go -package models api/openapi.yaml
oapi-codegen -generate chi-server -o internal/server/handlers/openapi_server.gen.go -package handlers api/openapi.yaml
```

Автотесты проверяют, что агент экспортирует и обновляет на сервере метрики, описанные в первых инкрементах.

## iter8
Добавьте поддержку `gzip` в код сервера и агента. Научите:
- Агент передавать данные в формате `gzip`.
- Сервер опционально принимать запросы в сжатом формате (при наличии соответствующего HTTP-заголовка `Content-Encoding`).
- Отдавать сжатый ответ клиенту, который поддерживает обработку сжатых ответов (с HTTP-заголовком `Accept-Encoding`).

Функция сжатия должна работать для контента с типами `application/json` и `text/html`.

## iter9
Доработайте код сервера, чтобы он мог с заданной периодичностью сохранять текущие значения метрик на диск в указанный файл, а на старте — опционально загружать сохранённые ранее значения. При штатном завершении сервера все накопленные данные должны сохраняться.

Сервер должен принимать соответствующие параметры конфигурации через флаги и переменные окружения:
- Флаг `-i`, переменная окружения `STORE_INTERVAL` — интервал времени в секундах, по истечении которого текущие показания сервера сохраняются на диск (по умолчанию 300 секунд, значение 0 делает запись синхронной).
- Флаг `-f`, переменная окружения `FILE_STORAGE_PATH` — полное имя файла, куда сохраняются текущие значения (по умолчанию /tmp/metrics-db.json, пустое значение отключает функцию записи на диск).
- Флаг `-r`, переменная окружения `RESTORE` — булево значение (true/false), определяющее, загружать или нет ранее сохранённые значения из указанного файла при старте сервера (по умолчанию true).

Приоритет параметров сервера должен быть таким:
- Если указана переменная окружения, то используется она.
- Если нет переменной окружения, но есть флаг, то используется он.
- Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

## iter10
Добавьте функциональность подключения к базе данных. В качестве СУБД используйте PostgreSQL не ниже 10 версии.

Добавьте в сервер хендлер `GET /ping`, который при запросе проверяет соединение с базой данных. При успешной проверке хендлер должен вернуть HTTP-статус `200 OK`, при неуспешной — `500 Internal Server Error`.

Строка с адресом подключения к БД должна получаться из переменной окружения `DATABASE_DSN` или флага командной строки `-d`.

Для работы с БД используйте один из следующих пакетов:
- database/sql
- github.com/jackc/pgx
- github.com/lib/pq
- github.com/jmoiron/sqlx

## iter11
Перепишите сервер для сбора метрик таким образом, чтобы СУБД PostgreSQL стала хранилищем метрик вместо текущей реализации.

Сервису нужно самостоятельно создать все необходимые таблицы в базе данных. 

Схема и формат хранения остаются на ваше усмотрение.

Для хранения значений gauge рекомендуется использовать тип `double precision`.
При отсутствии переменной окружения `DATABASE_DSN` или флага командной строки `-d` или при их пустых значениях вернитесь последовательно к:
- хранению метрик в файле при наличии соответствующей переменной окружения или флага командной строки;
- хранению метрик в памяти.

## iter12
### Сервер:
Добавьте новый хендлер `POST /updates/`, принимающий в теле запроса множество метрик в формате: `[]Metrics` (списка метрик).

### Агент:
Научите агент работать с использованием нового API (отправлять метрики батчами).

Стоит помнить, что:
- нужно соблюдать обратную совместимость;
- отправлять пустые батчи не нужно;
- вы умеете сжимать контент по алгоритму gzip;
- изменение в базе можно выполнять в рамках одной транзакции или одного запроса;
- необходимо избегать формирования условий для возникновения состояния гонки (race condition).

## iter13
Измените весь свой код в соответствии со знаниями, полученными в этой теме. Добавьте обработку retriable-ошибок.
Retriable-ошибки — это ошибки, которые могут быть исправлены повторной попыткой выполнения операции. Это бывает полезно для программ, которые работают с сетью или файловой системой, где возможны временные проблемы связи или доступа к данным. Ошибки могут быть вызваны различными причинами, такими как перегрузка сервера, недоступность сети или ошибки в коде программы.

Примеры retriable-ошибок:
- Ошибка связи с сервером при отправке запроса.
- Ошибка чтения данных из сети или БД из-за проблем соединения.
- Ошибка доступа к файлу, который был заблокирован другим процессом.

Сценарии возможных ошибок:
- Агент не сумел с первой попытки выгрузить данные на сервер из-за временной невозможности установить соединение с сервером.
- При обращении к PostgreSQL cервер получил ошибку транспорта (из категории `Class 08 — Connection Exception`).

Стратегия реализации:
- Количество повторов должно быть ограничено тремя дополнительными попытками.
- Интервалы между повторами должны увеличиваться: `1s`, `3s`, `5s`.
- Чтобы определить тип ошибки PostgreSQL, с которой завершился запрос, можно воспользоваться библиотекой `github.com/jackc/pgerrcode`, в частности `pgerrcode.UniqueViolation`.

## iter14
Реализуйте механизм подписи передаваемых данных по алгоритму `SHA256`. Для этого посчитайте hash от всего тела запроса и разместите его в HTTP-заголовке `HashSHA256`.
Хеш нужно считать от строки с учётом ключа, который передан агенту/серверу на старте: `hash(value, key)`.

Агент:
- Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
- При наличии ключа агент должен вычислять хеш и передавать в HTTP-заголовке запроса с именем `HashSHA256`.

Сервер:
- Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения `KEY=<КЛЮЧ>`.
- При наличии ключа во время обработки запроса сервер должен проверять соответствие полученного и вычисленного хеша.
- При несовпадении сервер должен отбрасывать полученные данные и возвращать `http.StatusBadRequest`.
- При наличии ключа на этапе формирования ответа сервер должен вычислять хеш и передавать его в HTTP-заголовке ответа с именем `HashSHA256`.

## iter15
Перепланируйте архитектуру агента таким образом, чтобы сбор метрик (опрос runtime) и их отправка осуществлялись в разных горутинах. При этом количество одновременно исходящих запросов на сервер нужно ограничивать «сверху».

Соответствующее значение должно задаваться аргументами:
- Через флаг `-l=<ЗНАЧЕНИЕ>`
- Через переменную окружения `RATE_LIMIT`.

Совет: 
- Используйте паттерн `worker pool`.

Добавьте ещё одну горутину, которая будет использовать пакет `gopsutil` и собирать дополнительные метрики типа gauge:
- `TotalMemory`,
- `FreeMemory`,
- `CPUutilization1` (точное количество — по числу CPU, определяемому во время исполнения).